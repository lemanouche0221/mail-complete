(*
		MAIL COMPLETE.SCPT
		By Chris Sauve of [pxldot](http://pxldot.com).
		See README for details.
*)
property onlyShowAvailableTasks : trueproperty actionWithSelectedMessages : "Yes, Archive" -- Either "Yes, Archive" or "Don't Archive"property actionWithSelectedTasks : "View in Project" -- Either "Complete" or "View in Project"property askEachTime : trueproperty firstTime : truetell application "Mail"	set senderList to {}	set theMessages to selected messages of front message viewer	if theMessages is missing value then		display alert "No messages were selected."		return	end ifend tellif askEachTime then	set actionWithSelectedTasks to button returned of (display dialog "Would you like to automatically complete tasks selected with this script or would like to view them in their containing projects in OmniFocus?" buttons {"View in Project", "Complete"} default button 2)	set actionWithSelectedMessages to button returned of (display dialog "Would you like to automatically archive the selected messages?" buttons {"Don't Archive", "Yes, Archive"} default button 2)end ifif firstTime then	set askEachTime to ((button returned of (display dialog "Would you like to have to choice to complete or view selected tasks and to archive selected messages each time you run this script?" buttons {"No, Don't Ask", "Yes, Ask Each Time"} default button 2)) is "Yes, Ask Each Time")	set firstTime to falseend iftell application "Mail"	repeat with aMessage in theMessages		set the end of senderList to (sender of aMessage)		if actionWithSelectedMessages is "Yes, Archive" then			set archiveFolder to my findArchiveFolder(aMessage)			move aMessage to end of archiveFolder		end if	end repeatend telltell application "OmniFocus"	tell default document		set waitContainer to the first flattened context where its name contains "Wait"		set possibleContextList to every flattened context where (its container is waitContainer)		set nameOfPossibleContextList to the name of every flattened context where (the name of its container contains "Wait")				set contextList to {}		set possibleContextSpot to my selectionPositions(senderList, nameOfPossibleContextList)		repeat with i from 1 to (length of possibleContextSpot)			set the end of contextList to (item (item i of possibleContextSpot) of possibleContextList)		end repeat				set waitingFor to {}		repeat with i from 1 to (length of contextList)			if onlyShowAvailableTasks then				set waitingFor to waitingFor & (every flattened task where (its context is (item i of contextList)) and (blocked is false) and (completed is false))			else				set waitingFor to waitingFor & (every flattened task where (its context is (item i of contextList)) and (completed is false))			end if		end repeat		set namesOfWaitingFor to {}		repeat with i from 1 to (length of waitingFor)			set end of namesOfWaitingFor to (name of (item i of waitingFor))		end repeat	end tellend tellif (length of waitingFor is 0) then	set noTasksFoundDialog to "No \"Waiting For\" tasks from this sender were found in your OmniFocus database."	set waitPerspectiveFound to false		tell application "OmniFocus"		set perspectiveList to every perspective		repeat with i from 1 to (length of perspectiveList)			if name of (item i of perspectiveList) contains "Wait" then				set waitPerspective to (item i of perspectiveList)				set waitPerspectiveName to name of (item i of perspectiveList)				set waitPerspectiveFound to true				set noTasksFoundDialog to (noTasksFoundDialog & " It looks like you have a perspective for tasks you're waiting for, though (the perspective named " & quote & waitPerspectiveName & quote & "). Do you want to open this perspective?")				exit repeat			end if		end repeat	end tell		if waitPerspectiveFound then		set buttonReturned to button returned of (display dialog noTasksFoundDialog buttons {"Cancel", "Show " & quote & waitPerspectiveName & quote} default button 2 with icon caution)	else		display alert noTasksFoundDialog		return	end if		if buttonReturned is "Cancel" then		return	else		tell application "OmniFocus"			activate			tell default document				set theWindow to make new document window				set perspective name of theWindow to (name of waitPerspective)			end tell		end tell	end ifelse	if actionWithSelectedTasks is "Complete" then		set chooseListText to "Select which \"Waiting For\" items from this sender, if any, to mark as complete:"		set chooseListTitle to "Complete \"Waiting For\" Tasks"		set chooseListOK to "Mark as Complete"	else		set chooseListText to "Select which \"Waiting For\" items from this sender, if any, to view in OmniFocus:"		set chooseListTitle to "View \"Waiting For\" Tasks"		set chooseListOK to "View in OmniFocus"	end if	set selectedTasks to choose from list namesOfWaitingFor with title chooseListTitle with prompt chooseListText OK button name chooseListOK with multiple selections allowed		if selectedTasks is false then		return	else		set positionOfSelections to selectionPositions(selectedTasks, namesOfWaitingFor)		tell application "OmniFocus"			if actionWithSelectedTasks is "Complete" then				repeat with i from 1 to (length of positionOfSelections)					set completed of item (item i of positionOfSelections) of waitingFor to true				end repeat			else				set projectList to {}				repeat with i from 1 to (length of positionOfSelections)					set end of projectList to containing project of (item (item i of positionOfSelections) of waitingFor)				end repeat				activate				tell default document					make new document window with properties {focus:projectList}				end tell			end if		end tell	end if	end ifon selectionPositions(selectList, originalList)	set j to 1	set choicesFound to 0	set positionOfSelections to {}	repeat until (j > (length of originalList)) or (choicesFound = (length of selectList))		set k to 1		set aChoiceFound to false		repeat until (k > (length of selectList)) or aChoiceFound			if (item k of selectList) contains (item j of originalList) then				set end of positionOfSelections to j				set aChoiceFound to true				set choicesFound to (choicesFound + 1)			end if			set k to k + 1		end repeat		set j to j + 1	end repeat	return positionOfSelectionsend selectionPositionson findArchiveFolder(theMessage)	tell application "Mail"		set theAccount to account of mailbox of theMessage		try			set theArchiveMailbox to item 1 of (get every mailbox of theAccount whose name contains "Archive")		on error			set theArchiveMailbox to null		end try		return theArchiveMailbox	end tellend findArchiveFolder